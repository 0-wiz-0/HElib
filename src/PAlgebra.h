/* Copyright (C) 2012,2013 IBM Corp.
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
#ifndef _PAlgebra_H_
#define _PAlgebra_H_
/* PAlgebra.h - Declatations of the classes PAlgebra...
 *
 * A PAlgebra object is determined by an integer m and a prime p,
 * where p does not divide m.
 *
 * It holds information descrtibing the structure of (Z/mZ)^*,
 * which is isomorphic to the Galois group over A = Z[X]/Phi_m(X)). 
 *
 * We represent (Z/mZ)^* as (Z/mZ)^* = <p> x <g1,g2,...> x <h1,h2,...>
 * where the group generated by g1,g2,... consists of the elements that
 * have the same order in (Z/mZ)^* as in (Z/mZ)^* /<p,g_1,...,g_{i-1}>, 
 * and h1,h2,... generate the remaining quotient group (Z/mZ)^* /<p,g1,g2,...>. 
 *
 * We let T \subset (Z/mZ)^* be a set of representatives for the quotient
 * group (Z/mZ)^* /<p>, defined as T={ \prod_i gi^{ei}\cdot\prod_j hj^{ej} }
 * where the ei's range over 0,1,...,ord(gi)-1 and the ej's range over
 * 0,1,...ord(hj)-1 (these last orders are in (Z/mZ)^* /<p,g1,g2,...>).
 *
 * Phi_m(X) is factored as Phi_m(X)=\prod_{t\in T} F_t(X) mod p,
 * where the F_t's are irreducible modulo p. An arbitrary factor
 * is chosen as F_1, then for each t \in T we associate with the index t the
 * factor F_t(X) = GCD(F_1(X^t), Phi_m(X)).
 *
 * Note that fixing a representation of the field R=(Z/pZ)[X]/F_1(X) 
 * and letting z be a root of F_1 in R (which
 * is a primitive m-th root of unity in R), we get that F_t is the minimal
 * polynomial of z^{1/t}.
 */

#include <vector>
#include <NTL/ZZX.h>
#include <NTL/GF2X.h>
#include <NTL/vec_GF2.h>
#include <NTL/GF2EX.h>
#include <NTL/lzz_pEX.h>

#include "cloned_ptr.h"


NTL_CLIENT
class PAlgebra {
  unsigned m;        // the integer m defines (Z/mZ)^*, Phi_m(X), etc.
  unsigned p;        // the prime base of the plaintext space

  unsigned phiM;     // phi(m)
  unsigned ordP;     // the order of p in (Z/mZ)^*
  unsigned nSlots;   // phi(m)/ordP = # of plaintext slots

  vector<unsigned> gens; // Our generators for (Z/mZ)^* (other than p)
  vector<long> ords; // ords[i] is the order of gens[i] in quotient group kept
                     // with a negative sign if different than order in (Z/mZ)*

  ZZX PhimX;   // Holds the integer polynomial Phi_m(X)
  double cM;   // the ring constant c_m for Z[X]/Phi_m(X)

  vector<unsigned> T; // The representatives for the quotient group (Z/mZ)^*/<p>
  vector<long> Tidx;  // i=Tidx[t] is the index i s.t. T[i]=t. 
                      // Tidx[t]==-1 if t\notin T

  vector<long> zmsIdx; // if t is the i'th element in (Z/mZ)* then zmsIdx[t]=i
                       // zmsIdx[t]==-1 if t\notin (Z/mZ)*

  vector<int> dLogT; 
  // holds the discrete-logarithms for elements in T: If (z/mZ)^*/<p>
  // has n generators then dLogT is an array of n*nSlots interest, where
  // the entries [in, in+1,...,(i+1)n-1] hold the discrete-logarithms for
  // the i'th element of (z/mZ)^*/<p>. 
  // Namely, for i<nSlots we have dLogT[in,...,(i+1)n-1] = [e1,...,en]
  // s.t. T[i] = \prod_{i=1}^n gi^{ei} mod m (with n=gens.size())

 public:

  PAlgebra(unsigned mm, unsigned pp = 2);  // constructor

  bool operator==(const PAlgebra& other) const;
  bool operator!=(const PAlgebra& other) const {return !(*this==other);}
  // comparison

  /* I/O methods */

  void printout() const;  // prints the structure in a readable form

  /* Access methods */

  unsigned getM() const { return m; }
  unsigned getP() const { return p; }

  unsigned getPhiM() const { return phiM; }
  unsigned getOrdP() const { return ordP; }
  unsigned getNSlots() const { return nSlots; }
  const ZZX& getPhimX() const { return PhimX; }


  unsigned numOfGens() const { return gens.size(); }
  unsigned ZmStarGen(unsigned i) const    // the i'th generator (if any)
  {  return (i<gens.size())? gens[i] : 0; }

  unsigned OrderOf(unsigned i) const // order of i'th generator (if any)
  {  return (i<ords.size())? abs(ords[i]) : 0; }

  bool SameOrd(unsigned i) const
  {  return (i<ords.size())? (ords[i]>0) : false; }
  // Is ord(i'th generator) the same as in (Z/mZ)^*? 

  /* Translation between index, represnetatives, and exponents */

  unsigned ith_rep(unsigned i) const // returns the i'th element in T
  {  return (i<nSlots)? T[i]: 0; }

  int indexOfRep(unsigned t) const   // returns the index of t in T
  {  return (t>0 && t<m)? Tidx[t]: -1; }

  bool isRep(unsigned t) const       // is t \in T?
  {  return (t>0 && t<m && Tidx[t]>-1); }

  int indexInZmstar(unsigned t) const   // returns the index of t in (Z/mZ)*
  {  return (t>0 && t<m)? zmsIdx[t]: -1; }

  bool inZmStar(unsigned t) const    // is t\in[0,m-1], (t,m)=1?
  {  return (t>0 && t<m && zmsIdx[t]>-1); }

  long coordinate(long i, long k) const;
  // returns ith coordinate of index k along the i'th dimension

  unsigned exponentiate(const vector<unsigned>& exps, 
			      bool onlySameOrd=false) const;
  // exponentiate(exps) returns prod_i gi^{exps[i]} mod m


  const int* dLog(unsigned t) const { // inverse of exponentiate
    int i = indexOfRep(t);
    if (i<0) return NULL;
    return &(dLogT[i*gens.size()]); // bug: this should be an iterator
  }

  /* Miscellaneous */

  unsigned qGrpOrd(bool onlySameOrd=false) const { 
    if (gens.size()<=0) return 1;
    unsigned ord = 1;
    for (unsigned i=0; i<ords.size(); i++)
      if (!onlySameOrd || SameOrd(i)) ord *= abs(ords[i]);
    return ord;
  }
  // The order of the quoteint group (Z/mZ)^* /<p> (if flag=false), or the
  // subgroup of elements with the same order as in (Z/mZ)^* (if flag=true)

  bool nextExpVector(vector<unsigned>& exps) const;
  // exps is an array of exponents (the dLog of some t\in T), this function
  // incerement exps lexicographic order, reutrn false if it cannot be
  // incremented (because it is at its maximum value)
};



/***************************************************************************

class: PAlgebraMod 

An object alMod of type PAlgebraMod stores information about a
PAlgebra object zMStar, and an integer r.  It also provides
support for encoding and decoding plaintext slots.

If zMStar defines p and m, then alMod stores various tables
of objects in the polynomial ring Z/(p^r)[X].  To do this most 
efficiently, if p == 2 and r == 1, then these polynomials
are represented as GF2X's, and otherwise as zz_pX's.
Thus, the types of these objects are not determined until run time.
As such, we need to use a class heirarchy, as follows.

PAlgebraModBase is a virtual class

PAlegbraModDerived<type> is a derived template class, where
type is either PA_GF2 or PA_zz_p.

The class PAlgebraMod is a simple wrapper around a smart pointer to a
PAlgebraModBase object: copying a PAlgebra object results is
a "deep copy" of the underlying object of the derived class.


***************************************************************************/


enum PA_tag { PA_GF2_tag, PA_zz_p_tag };



class DummyBak {
// placeholder class used in GF2X impl

public:
  void save() {}
  void restore() const {}
};

class DummyContext {
// placeholder class used in GF2X impl

public:
  void save() {}
  void restore() const {}
  DummyContext() {}
  DummyContext(long) {}
};




class PA_GF2 {
// typedefs for algebraic structires built up from GF2

public:
  static const PA_tag tag = PA_GF2_tag;
  typedef GF2X RX;
  typedef vec_GF2X vec_RX;
  typedef GF2XModulus RXModulus;
  typedef DummyBak RBak;
  typedef DummyContext RContext;
  typedef GF2E RE;
  typedef vec_GF2E vec_RE;
  typedef GF2EX REX;
  typedef GF2EBak REBak;
  typedef vec_GF2EX vec_REX;
  typedef GF2EContext REContext;
};


class PA_zz_p {
// typedefs for algebraic structires built up from zz_p

public:
  static const PA_tag tag = PA_zz_p_tag;
  typedef zz_pX RX;
  typedef vec_zz_pX vec_RX;
  typedef zz_pXModulus RXModulus;
  typedef zz_pBak RBak;
  typedef zz_pContext RContext;
  typedef zz_pE RE;
  typedef vec_zz_pE vec_RE;
  typedef zz_pEX REX;
  typedef zz_pEBak REBak;
  typedef vec_zz_pEX vec_REX;
  typedef zz_pEContext REContext;
};



class PAlgebraModBase {
// Virtual base class for PAlgebraMod

public:

  virtual ~PAlgebraModBase() {}
  virtual PAlgebraModBase* clone() const = 0;

  virtual PA_tag getTag() const = 0;
  virtual const PAlgebra& getZMStar() const = 0;
  virtual const vector<ZZX>& getFactorsOverZZ() const = 0;
  virtual long getR() const  = 0;
  virtual long getPPowR() const = 0;
  virtual void restoreContext() const = 0;

  virtual void genMaskTable() const = 0;
};


#define PA_INJECT(type) \
  static const PA_tag tag = type::tag;  \
  typedef typename type::RX RX;  \
  typedef typename type::vec_RX vec_RX;  \
  typedef typename type::RXModulus RXModulus;  \
  typedef typename type::RBak RBak;  \
  typedef typename type::RContext RContext;  \
  typedef typename type::RE RE;  \
  typedef typename type::vec_RE vec_RE;  \
  typedef typename type::REX REX;  \
  typedef typename type::REBak REBak;  \
  typedef typename type::vec_REX vec_REX;  \
  typedef typename type::REContext REContext;  \


template<class type> class PAlgebraModDerived;
// forward declaration

template<class type> class MappingData {
// auxilliary structure to support encoding/decoding slots.

public:
  PA_INJECT(type)

  friend class PAlgebraModDerived<type>;

private:
  RX G; // the polynomial defining the field extension
  long degG; // the degree of the polynomial

  /* the remaining fields are visible only to
     PAlgebraModDerived
   */

  vector<RX> maps;
  REContext contextForG;
  vector<REX> rmaps;

public:
  const RX& getG() const { return G; }
  long getDegG() const { return degG; } 
};


template<class type> class PAlgebraModDerived : public PAlgebraModBase {
public:
  PA_INJECT(type)


private:
  const PAlgebra& zMStar;
  long r;
  long pPowR;
  RContext pPowRContext;

  RXModulus PhimXMod;

  vec_RX factors;
  vector<ZZX> factorsOverZZ;
  vec_RX crtCoeffs;
  vector< vector< RX > > maskTable;


public:

  PAlgebraModDerived(const PAlgebra& zMStar, long r);


  PAlgebraModDerived(const PAlgebraModDerived& other) // copy constructor
  : zMStar(other.zMStar), r(other.r), pPowR(other.pPowR), 
    pPowRContext(other.pPowRContext)
  {
    RBak bak; bak.save(); restoreContext();
    PhimXMod = other.PhimXMod;
    factors = other.factors;
    maskTable = other.maskTable;
  }

  PAlgebraModDerived& operator=(const PAlgebraModDerived& other) // assignment
  {
    if (this == &other) return *this;

    assert(&zMStar == &other.zMStar);
    r = other.r;
    pPowR = other.pPowR;
    pPowRContext = other.pPowRContext;

    RBak bak; bak.save(); restoreContext();
    PhimXMod = other.PhimXMod;
    factors = other.factors;
    maskTable = other.maskTable;

    return *this;
  }

  virtual PAlgebraModBase* clone() const { return new PAlgebraModDerived(*this); }
  // returns a pointer to a "clone"


  virtual PA_tag getTag() const { return tag; }
  // returns the type tag: PA_GF2_tag or PA_zz_p_tag

  virtual const PAlgebra& getZMStar() const { return zMStar; }
  // returns reference to underlying PAlgebra object

  virtual const vector<ZZX>& getFactorsOverZZ() const { return factorsOverZZ; }
  // returns reference to the factorization of Phi_m(X) mod p^r,
  // but as ZZX's

  virtual long getR() const { return r; }
  // the value r

  virtual long getPPowR() const { return pPowR; }
  // the value p^r

  virtual void restoreContext() const { pPowRContext.restore(); }
  // restores the context for p^r

  virtual void genMaskTable() const; // logically, but not really, const
  // generates the "mask table" that is used to support rotations


  /* In all of the following functions, it is expected that the caller 
     has already restored the relevant modulus (p^r), which
     can be done by invoking the method restoreContext()
   */

  const RXModulus& getPhimXMod() const { return PhimXMod; }
  // returns reference to an RXModulus representing Phi_m(X) (mod p^r)

  const vec_RX& getFactors() const { return factors; }
  // returns reference to the factors of Phim_m(X) modulo p^r

  const vec_RX& getCrtCoeffs() const { return crtCoeffs; }
  // returns the CRT coefficients: element i contains
  // (prod_{j!=i} F_j)^{-1} mod F_i, where F_0 F_1 ... is
  // the factorization of Phi_m(X) mod p^r


  const vector< vector< RX > >& getMaskTable() const
  {
    if (maskTable.size() == 0) 
      genMaskTable();
    return maskTable;
  }
  // logically, but not really, const
  // returns ref to maskTable, where
  //   maskTable.size() == zMStar.numOfGens() /* # of generators */
  //   for i = 0..maskTable.size()-1:
  //     maskTable[i].size() == zMStar.OrderOf(i) /* order of generator i */
  //     for j = 0..maskTable[i].size() - 1
  //       maskTable[i][j] is a polynomial representation of a mask
  //         which is 1 in all slots whose ih coordinate is at least j
  //         and 0 in all other slots
  // maskTable is used to implement rotations (in the EncryptedArray module)



  // Embedding in the plaintext slots and decoding back

  // In all the functions below, G must be irredicible mod p, 
  // and the order of G must divide the order of p modulo m
  // (as returned by zMStar.getOrdP()).
  // In addition, when r > 1, G must be the monomial X (RX(1, 1))

  void CRT_decompose(vector<RX>& crt, const RX& H) const;
  // Returns a vector crt[] such that crt[i] = H mod Ft (with t = T[i])

  void CRT_reconstruct(RX& H, vector<RX>& crt) const;
  // Returns H \in R[X]/Phi_m(X) s.t. for every i<nSlots and t=T[i],
  // we have H == crt[i] (mod Ft)

  void mapToSlots(MappingData<type>& mappingData, const RX& G) const;
  // Compute the maps for all the slots
  // In the current implementation, we if r > 1, then
  // we must have either deg(G) == 1 or G == factors[0]

  void embedInAllSlots(RX& H, const RX& alpha, 
                       const MappingData<type>& mappingData) const;
  // Returns H \in R[X]/Phi_m(X) s.t. for every t \in T, the element
  // Ht = (H mod Ft) \in R[X]/Ft(X) represents the same element as
  // alpha \in R[X]/G(X). Must have deg(alpha)<deg(G).
  // The mappingData argument should contain the output of mapToSlots(G).

  void embedInSlots(RX& H, const vector<RX>& alphas, 
                    const MappingData<type>& mappingData) const;
  // Returns H \in R[X]/Phi_m(X) s.t. for every i<nSlots and t=T[i],
  // the element Ht = (p mod Ft) \in R[X]/Ft(X) represents the same
  // element as alphas[i] \in R[X]/G(X). Must have deg(alphas[i])<deg(G).
  // The mappingData argument should contain the output of mapToSlots(G).

  void decodePlaintext(vector<RX>& alphas, const RX& ptxt,
		       const MappingData<type>& mappingData) const;
  // return an array such that alphas[i] \in R[X]/G(X) represent the
  // same element as rt = (H mod Ft) \in R[X]/Ft(X) where t=T[i].
  // The mappingData argument should contain the output of mapToSlots(G).


  void buildLinPolyCoeffs(vector<RX>& C, const vector<RX>& L,
                          const MappingData<type>& mappingData) const;
  // G is assumed to be defined in mappingData, with d = deg(G).
  // L describes a linear map M by describing its action on
  //    the standard power basis: M(x^j mod G) = (L[j] mod G),
  //    for j = 0..d-1.  
  // The result is a coefficient vector C for the linearized
  //    polynomial representing M:   for h in Z/(p^r)[X] of degree < d,  
  //    M(h(X) mod G) = sum_{i=0}^{d-1} (C[j] mod G) * (h(X^{p^j}) mod G).


private:
  /* internal functions, not for public consumption */

  static void SetModulus(long p) {
    RContext context(p);
    context.restore();
  }

  void mapToF1(RX& w, const RX& G) const { mapToFt(w,G,1); }
  // w \in R[X]/F1(X) represents the same as X \in R[X]/G(X)

  void mapToFt(RX& w, const RX& G, unsigned t, const RX* rF1=NULL) const;
  // Same as above, but embeds relative to Ft rather than F1. The
  // optional rF1 contains the output of mapToF1, to speed this operation.


};


PAlgebraModBase *buildPAlgebraMod(const PAlgebra& zMStar, long r);
// builds a table, of type PA_GF2 if p == 2 and r == 1, and PA_zz_p otherwise




class PAlgebraMod {
// A simple wrapper for a pointer to an object of type PAlgebraModBase.
// Direct access to the virtual methods of PAlgebraModBase is provided,
// along with a "downcast" operator to get a reference to the object
// as a derived type, and == and != operators.

private:
  cloned_ptr<PAlgebraModBase> rep;

public:
  // copy constructor: default
  // assignment: default
  // destructor: default
  // NOTE: the use of cloned_ptr ensures that the default copy constructor,
  // assignment operator, and destructor will work correctly.

  explicit
  PAlgebraMod(const PAlgebra& zMStar, long r) 
  : rep( buildPAlgebraMod(zMStar, r) )
  { }
  // constructor


  template<class type> 
  const PAlgebraModDerived<type>& getDerived(type) const
  { return dynamic_cast< const PAlgebraModDerived<type>& >( *rep ); }
  // downcast operator
  // example: const PAlgebraModDerived<PA_GF2>& rep = alMod.getDerived(PA_GF2());
  
  
  bool operator==(const PAlgebraMod& other) const
  {
    return getZMStar() == getZMStar() && getR() == other.getR();
  }
  // comparison

  bool operator!=(const PAlgebraMod& other) const
  {
    return !(*this == other);
  }
  // comparison



  /* direct access to the PAlgebraModBase methods */

  PA_tag getTag() const { return rep->getTag(); }
  const PAlgebra& getZMStar() const { return rep->getZMStar(); }
  const vector<ZZX>& getFactorsOverZZ() const { return rep->getFactorsOverZZ(); }
  long getR() const { return rep->getR(); } 
  long getPPowR() const { return rep->getPPowR(); }
  void restoreContext() const { rep->restoreContext(); }

  void genMaskTable() const { rep->genMaskTable(); }


};



#endif // #ifdef _PAlgebra_H_
